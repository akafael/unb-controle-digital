% Pacotes e configurações padrão do estilo ``article''\
% -------------------------------------
\documentclass[a4paper,11pt]{article}
% Layout
% ------------------------------------------------------------------------------
\input{relat_layout.tex}

\usepackage{circuitikz}
\usepackage[makestderr]{pythontex}

\title{Laboratório 2} % Define o título do Relatório
\author{Rafael Lima}

% Definições Auxiliares ( Macros próprias )
% ------------------------------------------------------------------------------
%\input{relat_aux.tex} % Arquivo com minhas macros
\newcommand{\npy}[1]{\sympy{round(#1,4)}}
% ----------------------------------~>ø<~---------------------------------------
\begin{document}
% Capa e Índice ----------------------------------------------------------------
\input{relat_capa.tex} % Capa para UnB
% Conteúdo ---------------------------------------------------------------------

\section{Comparação entre diferentes métodos de Discretização}

% Código fonte colocado a parte para facilitar validação dentro do ipython
\begin{sympycode}
# Get Source Code
sys.path.insert(1, '../../')
from src.python.exsim2 import *
\end{sympycode}

Dado a função de transferência \ref{eq:ex2-tf}

\begin{equation}\label{eq:ex2-tf}
\sympy{sGo}
\end{equation}

\subsection{Transformada z de G(s) com segurador de ordem zero em série}

Aplicando a discretização temos:

$$
\begin{array}{lcl}
    Z(\frac{1-e^{-Ts}}{s}G(z)) &=& Z(\frac{1}{s}G(z)) - Z(\frac{e^{-Ts}}{s}G(z))\\
    &=& Z(\frac{1}{s}G(z)) - (z^{-1})Z(\frac{1}{s}G(z))\\
    &=& (1 - z^{-1})Z(\frac{1}{s}G(z))\\
    &=& (1 - z^{-1})Z(\sympy{(1/s)*sGo})\\
\end{array}
$$

Fatorando o termo $\sympy{(1/s)*sGo}$ pelo método de frações parciais temos

\begin{equation}\label{eq:ex2-partialfrac}
    \sympy{sGo/s} = \sympy{partialFraction(sGo/s,s)}
\end{equation}

Pela tabela, temos que a transformada z de \ref{eq:ex2-partialfrac} é

$$Z\{G(s)\} = \sympy{zGo}$$
$$Z\{G(s)\} = \sympy{zGo.combsimp()}$$

Logo, substituindo $T = \sympy{nT}$, temos:

\begin{equation}
  G_o(z) = \sympy{zGo.combsimp().subs(T,nT)}
\end{equation}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{img/exsim2-plot-g-zoh.png}
    \caption{Resposta ao Degrau Unitário do Sistema Discretizado com um Segurador de Ordem Zero}
\end{figure}

\subsection{Regra Retangular para frente}

$$
G_b(z) =  G(z)|_{s = \sympy{Gzb}} = \sympy{Gob}
$$

\begin{equation}
    G_b(z) = \sympy{simplifyFraction(Gob,z)}
\end{equation}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{img/exsim2-plot-g-forward.png}
    \caption{Resposta ao Degrau Unitário do Sistema discretizado pela regra retangular para frente}
\end{figure}

\subsection{Regra Retangular para trás}

$$
G_f(z) =  G(z)|_{s = \sympy{Gzf}} = \sympy{Gof}
$$

\begin{equation}
    G_f(z) = \sympy{simplifyFraction(Gof,z)}
\end{equation}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{img/exsim2-plot-g-backward.png}
    \caption{Resposta ao Degrau Unitário do Sistema discretizado pela regra retangular para trás}
\end{figure}

\subsection{Regra trapezoidal}

$$
G_d(z) =  G(z)|_{s = \sympy{Gzd}} = \sympy{God}
$$

\begin{equation}
    G_d(z) = \sympy{simplifyFraction(God,z)}
\end{equation}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{img/exsim2-plot-g-trap.png}
    \caption{Resposta ao Degrau Unitário do Sistema discretizado pela regra trapezoidal}
\end{figure}

\subsection{Mapeamento exato de pólos e zeros}

A função de transferência têm como polos $s_1=-2$ e $s_2=-3$. Mapeando no plano z temos $z = e^{sT}$

\section{Projeto Sistema em Tempo Discreto}

\begin{equation}
    G(s) = \frac{Y(s)}{U(s)} = \sympy{G2}
\end{equation}

\begin{equation}
    U(s) = \sympy{G1}U_C(s) - \sympy{H2}Y(s)
\end{equation}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{img/exsim2-plot-g-matched.png}
    \caption{Resposta ao Degrau Unitário do Sistema discretizado por mapeamento exato dos polos}
\end{figure}
'
\subsection{Sistema em Malha Fechada}

$$G_{mf}(s) = \sympy{G1*G2/(1+G2*H2)}$$
$$G_{mf}(s) = \sympy{G2mf}$$

Substituindo $a = \sympy{2*w0}$ e $b = \sympy{w0/2}$ temos

\begin{equation}
    G_{mf}(s) = \sympy{simplifyFraction(G2mf.subs([(a,2*w0),(b,w0/2),(kc,2*J*w0*w0/kp)]),s)}
\end{equation}

\subsection{Resposta em frequência}
\subsection{Ação de Controle}
\subsection{Simulink}
\subsection{}

\section{Conclusão}

% ------------------------------------------------------------------------------

\nocite{sympy}
\bibliographystyle{abbrv}
\bibliography{references}
% Referências
% Acrescentadas no arquivo references.bib
% para usa-las no texto batsa usar \citep{}

% ------------------------------------------------------------------------------
\newpage
\section{Anexos}
\subsection{Python}

Para o avaliação da estabilidade usando o critério de Jury e o critério de Roth modificado foi utilizado o seguinte código em python:

\inputminted[xleftmargin=15pt,linenos,frame=single,framesep=5pt]{python}{../python/exsim2.py}

\newpage
\subsection{Matlab}

Para o desenho dos gráficos e simulações foi utilizado o \textit{Matlab}. Segue o código referente para as simulações

\inputminted[xleftmargin=15pt,linenos,frame=single,framesep=5pt]{matlab}{../matlab/exsim2/exsim2.m}


% ------------------------------------------------------------------------------
\end{document}
